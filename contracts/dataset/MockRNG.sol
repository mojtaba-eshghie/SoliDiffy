//SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

// import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "../interfaces/IRegistry.sol";

/**
    @dev Mock contract for RNG
 */
contract MockRNG is IRNG {
    IRegistry registry;

    string constant ERR_REQ_ALR_FULFILLED = "Request already fulfilled";
    string constant ERR_REQ_NOT_FULFILLED = "Request isn't fulfilled";
    string constant ERR_RAND_NOT_READY = "Random number isn't ready";
    string constant ERR_RAND_EMPTY = "Random number is empty, request again";
    string constant ERR_ENOUGH_LINK = "Not enough LINK in contract";

    uint256 nonce = 0;

    // Chainlink variables
    bytes32 private keyHash;
    uint256 private fee;

    event ChainlinkRandomFulfilled(address caller);
    event BlockRandomFulfilled(address caller);

    /**
        Struct to hold random number requests
        @member fulfilled:  If the request is fulfilled
        @member blockNum:   Block number
        @member num:        Random number, if there's one
    */
    struct BlockRandom {
        bool fulfilled;
        uint256 blockNum;
        uint256 num;
    }

    mapping(address => BlockRandom) userToBlockRandom;
    mapping(bytes32 => address) clRequestToUser;
    mapping(address => uint256) userToClRandom;

    modifier authorized() {
      require(registry.authorized(msg.sender), "NOT_AUTHORIZED");
      _;
    }

    constructor(IRegistry registryAddress) {
        keyHash = bytes32(block.number);
        fee = 0.1 * 1e18;

        registry = IRegistry(registryAddress);
    }

    // ############## BLOCKHASH BASED RANDOM ############## //

    /**
        @notice Requests block random    
     */
    function requestBlockRandom(address caller) external authorized {
        require(!userToBlockRandom[caller].fulfilled, ERR_REQ_ALR_FULFILLED);

        userToBlockRandom[caller] = BlockRandom({fulfilled: true, blockNum: block.number, num: 0});
    }

    /**
        @notice Checks the block random request and generates the number if 
        the request is ready.
        @dev Blockhashes expire at 256 blocks, if it's expired BlockRandom.num
        will default to 0 without assignment    
        @dev Emits BlockRandomFulfilled
     */
    function checkBlockRandom(address caller) external {
        require(userToBlockRandom[caller].fulfilled, ERR_REQ_NOT_FULFILLED);

        // To save for multiple SLOADs
        uint256 prevBlockNum = userToBlockRandom[caller].blockNum;

        require(prevBlockNum < block.number, ERR_RAND_NOT_READY);

        if (block.number - prevBlockNum <= 256) {
            userToBlockRandom[caller].num = uint256(
                keccak256(abi.encodePacked(prevBlockNum, caller))
            );

            emit BlockRandomFulfilled(caller);
        }

        userToBlockRandom[caller].fulfilled = false;
    }

    function testGetHash(address caller) external view returns(uint256){
        return userToBlockRandom[caller].blockNum;
    }

    /**
        @notice Checks if block random exists and returns if it does
        @return Random number generated by blockhash
     */
    function getBlockRandom(address caller) external view returns (uint256) {
        require(userToBlockRandom[caller].num != 0, ERR_RAND_EMPTY);
        return userToBlockRandom[caller].num;
    }

    /**
        @notice Deletes the random number (it is assumed to be called after usage)
    */
    function resetBlockRandom(address caller) external authorized {
        delete userToBlockRandom[caller];
    }

    // ############## CHAINLINK RANDOM ############## //

    /**
        @notice Requests random from Chainlink
    */
    function requestChainlinkRandom(address caller)
        external
        authorized
        returns (bytes32 requestId)
    {
        //require(LINK.balanceOf(address(this)) >= fee, ERR_ENOUGH_LINK);
        //requestId = requestRandomness(keyHash, fee);

        requestId = keccak256(abi.encode(nonce++));

        clRequestToUser[requestId] = caller;

        fulfillRandomness(requestId, uint256(requestId));
    }

    /**
        @notice The function Chainlink calls to fulfill randomness request
        @dev Emits ChainlinkRandomFulfilled
    */
    function fulfillRandomness(bytes32 _requestId, uint256 _randomness) internal {
        address requestAddress = clRequestToUser[_requestId];
        require(requestAddress != address(0), ERR_REQ_NOT_FULFILLED);

        userToClRandom[requestAddress] = _randomness;

        emit ChainlinkRandomFulfilled(requestAddress);

        // Clean used request ID slot
        delete clRequestToUser[_requestId];
    }

    /**
        @notice Checks if block random exists and returns if it does
        @return Random number generated by Chainlink
     */
    function getChainlinkRandom(address caller) external view returns (uint256) {
        require(userToClRandom[caller] != 0, ERR_RAND_EMPTY);
        return userToClRandom[caller];
    }

    /**
        @notice Deletes the random number (it is assumed to be called after usage)
    */
    function resetChainlinkRandom(address caller) external authorized {
        delete userToClRandom[caller];
    }
}
