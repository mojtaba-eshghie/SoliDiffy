//SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "chainlink/VRFConsumerBase.sol";

import "../utils/Errors.sol";
import "../interfaces/IRegistry.sol";

/**
  @notice Holds random number requests and generates new random numbers
  
  @dev Each address has one Chainlink random and one blockhash random
  @dev Contract uses two strategies to generate random numbers
    - By using blockhash:
    Utilizes the fact that current block's hash isn't known before the block is finalized
    Uses a commitment scheme with two transactions. First transaction saves a BlockRandom
    request which stores the current blocknumber. Second transaction can only be called
    in the next block and checks the request block's hash to generate the random number

    - By using Chainlink:
    Utilizes Chainlink VRF.
    Uses a two transaction mechanism where the first txn is called by the user and the second
    one is called by Chainlink contract. After this call the result is stored in a separate
    mapping
  @dev Random numbers are supposed to be called from authrorized game contracts. After a random
  number is called from an authorized contract, contract resets the random number

  @author Ulas Erdogan
*/
contract RNG is VRFConsumerBase {
  IRegistry registry;

  string constant ERR_REQ_ALR_FULFILLED = "Request already fulfilled";
  string constant ERR_REQ_NOT_FULFILLED = "Request isn't fulfilled";
  string constant ERR_RAND_NOT_READY = "Random number isn't ready";
  string constant ERR_RAND_EMPTY = "Random number is empty, request again";
  string constant ERR_ENOUGH_LINK = "Not enough LINK in contract";

  // Chainlink variables
  bytes32 private keyHash;
  uint256 private fee;

  event ChainlinkRandomFulfilled(address caller);
  event BlockRandomFulfilled(address caller);

  /**
    Struct to hold random number requests
    @member fulfilled:  If the request is fulfilled
    @member blockNum:   Block number
    @member num:        Random number, if there's one
  */
  struct BlockRandom {
    bool fulfilled;
    uint256 blockNum;
    uint256 num;
  }

  mapping(address => BlockRandom) userToBlockRandom;
  mapping(bytes32 => address) clRequestToUser;
  mapping(address => uint256) userToClRandom;

  modifier authorized() {
    require(registry.authorized(msg.sender), "Not authorized");
    _;
  }

  constructor(
    address _vrfCoordinator,
    address _link,
    bytes32 _keyHash,
    uint256 _fee,
    IRegistry registryAddress
  ) VRFConsumerBase(_vrfCoordinator, _link) {
    keyHash = _keyHash;
    fee = _fee;

    registry = IRegistry(registryAddress);
  }

  // ############## BLOCKHASH BASED RANDOM ############## //

  /**
    @notice Requests block random    
  */
  function requestBlockRandom(address caller) external authorized {
    userToBlockRandom[caller] = BlockRandom({fulfilled: true, blockNum: block.number, num: 0});
  }

  /**
    @notice Checks the block random request and generates the number if 
    the request is ready.
    @dev Blockhashes expire at 256 blocks, if it's expired BlockRandom.num
    will default to 0 without assignment    
    @dev Emits BlockRandomFulfilled
  */
  function checkBlockRandom(address caller) external {
    require(userToBlockRandom[caller].fulfilled, Errors.REQ_NOT_FULFILLED);

    // To save for multiple SLOADs
    uint256 prevBlockNum = userToBlockRandom[caller].blockNum;
    require(block.number - prevBlockNum <= 256, Errors.REQ_LATE);

    require(prevBlockNum < block.number, Errors.RAND_NOT_READY);

    if (block.number - prevBlockNum <= 256) {
      userToBlockRandom[caller].num = uint256(
        keccak256(abi.encodePacked(blockhash(prevBlockNum), caller))
      );

      emit BlockRandomFulfilled(caller);
    }

    userToBlockRandom[caller].fulfilled = false;
  }

  /**
    @notice Checks if block random exists and returns if it does
    @return Random number generated by blockhash
  */
  function getBlockRandom(address caller) external view returns (uint256) {
    require(userToBlockRandom[caller].num != 0, Errors.RAND_EMPTY);
    return userToBlockRandom[caller].num;
  }

  /**
    @notice Deletes the random number (it is assumed to be called after usage)
  */
  function resetBlockRandom(address caller) external authorized {
    delete userToBlockRandom[caller];
  }

  // ############## CHAINLINK RANDOM ############## //

  /**
    @notice Requests random from Chainlink
  */
  function requestChainlinkRandom(address caller)
    external
    authorized
    returns (bytes32 requestId)
  {
    require(LINK.balanceOf(address(this)) >= fee, Errors.ENOUGH_LINK);

    requestId = requestRandomness(keyHash, fee);

    clRequestToUser[requestId] = caller;
  }

  /**
    @notice The function Chainlink calls to fulfill randomness request
    @dev Emits ChainlinkRandomFulfilled
  */
  function fulfillRandomness(bytes32 _requestId, uint256 _randomness) internal override {
    address requestAddress = clRequestToUser[_requestId];
    require(requestAddress != address(0), Errors.REQ_NOT_FULFILLED);

    userToClRandom[requestAddress] = _randomness;

    emit ChainlinkRandomFulfilled(requestAddress);

    // Clean used request ID slot
    delete clRequestToUser[_requestId];
  }

  /**
    @notice Checks if block random exists and returns if it does
    @return Random number generated by Chainlink
  */
  function getChainlinkRandom(address caller) external view returns (uint256) {
    require(userToClRandom[caller] != 0, Errors.RAND_EMPTY);
    return userToClRandom[caller];
  }

  /**
    @notice Deletes the random number (it is assumed to be called after usage)
  */
  function resetChainlinkRandom(address caller) external authorized {
    delete userToClRandom[caller];
  }
}
